<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <style> body { margin: 0; } </style>
    <script src="//cdn.jsdelivr.net/npm/force-graph"></script>
    <!--<script src="../../dist/force-graph.js"></script>-->
    <link rel="stylesheet" href="style.css">
  </head>

  <body>

    <div id="caption">
      <h1>
        Druid Confluence Map
      </h1>
      <p>
        the hidden ecosystem of Guild Wars' nature magic (fanon)<br>
      </p>
      <p id="fine">
        (2025) made by Deltise.7236 using <a href="https://github.com/vasturiano/force-graph">force-graph</a><br>
        <a href="https://github.com/eb-del/gw-druid-diagram">source</a> - <a href="https://bsky.app/profile/ebdel.bsky.social">bluesky</a>
      </p>
    </div>

    <div id="graph">
    </div>


    <script type="module">

      // Making the force-directed graph
      fetch('./data/attunements.json').then(res => res.json()).then(data => {
        const Graph = new ForceGraph(document.getElementById('graph'))

          .graphData(data)

          .nodeId('id')

          //.d3Force('cluster', () => {})
          .cooldownTime(Infinity)

          .linkColor(() => '#ffffff33')
          .linkCurvature(0.05)

          // Makes text
          .nodeCanvasObject((node, ctx, globalScale) => {
            const label = node.id;
            const fontSize = (12/globalScale) * node.scale;

            const nimg = urlToImage(node.img);

            ctx.font = `${fontSize}px Sans-Serif`;
            const textWidth = ctx.measureText(label).width;

            const bckgDimensions = [textWidth + fontSize, fontSize].map(n => n + fontSize * 0.4); // some padding
            ctx.fillStyle = '#272c2e55';
            //ctx.fillStyle = '#888888';
            ctx.fillRect(
              (node.x - bckgDimensions[0] / 2) + (textWidth / 2),
              node.y - bckgDimensions[1] / 2,
              ...bckgDimensions);

            ctx.drawImage(
              nimg,
              node.x - fontSize / 2,
              node.y - fontSize / 2,
              fontSize,
              fontSize);

            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = node.color;
            ctx.fillText(
              label,
              node.x + (fontSize / 2), // shift to make room for icon
              node.y); // loads text

            node.__bckgDimensions = bckgDimensions; // to re-use in nodePointerAreaPaint
          })

          // Makes text clickable
          .nodePointerAreaPaint((node, color, ctx) => {
            ctx.fillStyle = color;
            const label = node.id;
            const bckgDimensions = node.__bckgDimensions;
            const textWidth = ctx.measureText(label).width;
            bckgDimensions && ctx.fillRect(
              (node.x - bckgDimensions[0] / 2) + (textWidth / 2),
              node.y - bckgDimensions[1] / 2,
              ...bckgDimensions);
          });

      });

      // converts url stored in json to canvas image
      function urlToImage(url) {
        const img = new Image();
        img.src = url;
        return img;
      }

    </script>
  </body>
</html>
